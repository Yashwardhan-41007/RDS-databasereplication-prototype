name: RDS Replication

# SECURITY: Passwords are automatically masked in logs (appear as ***)
# Uses AWS SSM to execute commands on EC2 instance inside VPC
# Requires: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, SSM_INSTANCE_ID secrets in GitHub

on:
  # Manual trigger - Click "Run workflow" button in GitHub Actions tab
  workflow_dispatch:
    inputs:
      database_name:
        description: 'Database name to replicate'
        required: true
        default: 'dummy'
      src_host:
        description: 'Source RDS Host'
        required: true
      src_user:
        description: 'Source RDS Username'
        required: true
      src_pass:
        description: 'Source RDS Password'
        required: true
      tgt_host:
        description: 'Target RDS Host'
        required: true
      tgt_user:
        description: 'Target RDS Username'
        required: true
      tgt_pass:
        description: 'Target RDS Password'
        required: true

jobs:
  replicate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Mask Sensitive Data
      run: |
        echo "::add-mask::${{ inputs.src_pass }}"
        echo "::add-mask::${{ inputs.tgt_pass }}"
        echo "üîí Passwords masked in logs"
    
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-south-1
        
    - name: Test Source RDS Connection via SSM
      env:
        SRC_PASS: ${{ inputs.src_pass }}
      run: |
        echo "üîç Testing source RDS connection via SSM..."
        
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.SSM_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --comment "Test source RDS connectivity" \
          --parameters "commands=[\"mysql -h ${{ inputs.src_host }} -u ${{ inputs.src_user }} -p'${SRC_PASS}' -e 'SELECT 1' 2>&1\"]" \
          --query "Command.CommandId" \
          --output text)
        
        echo "SSM Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --timeout 30 || true
        
        # Get command output
        OUTPUT=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardOutputContent" \
          --output text)
        
        echo "$OUTPUT"
        
        # Check if successful
        if echo "$OUTPUT" | grep -q "1"; then
          echo "‚úÖ Source RDS connection successful"
        else
          echo "‚ùå Source RDS connection failed"
          exit 1
        fi
    
    - name: Test Target RDS Connection via SSM
      env:
        TGT_PASS: ${{ inputs.tgt_pass }}
      run: |
        echo "üîç Testing target RDS connection via SSM..."
        
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.SSM_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --comment "Test target RDS connectivity" \
          --parameters "commands=[\"mysql -h ${{ inputs.tgt_host }} -u ${{ inputs.tgt_user }} -p'${TGT_PASS}' -e 'SELECT 1' 2>&1\"]" \
          --query "Command.CommandId" \
          --output text)
        
        echo "SSM Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --timeout 30 || true
        
        # Get command output
        OUTPUT=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardOutputContent" \
          --output text)
        
        echo "$OUTPUT"
        
        # Check if successful
        if echo "$OUTPUT" | grep -q "1"; then
          echo "‚úÖ Target RDS connection successful"
        else
          echo "‚ùå Target RDS connection failed"
          exit 1
        fi
        
    - name: Replicate Database via SSM
      env:
        SRC_PASS: ${{ inputs.src_pass }}
        TGT_PASS: ${{ inputs.tgt_pass }}
      run: |
        echo "üîÑ Starting replication of database: ${{ github.event.inputs.database_name }}"
        echo "Source: ${{ inputs.src_host }}"
        echo "Target: ${{ inputs.tgt_host }}"
        echo ""
        
        # Create the replication command
        REPLICATION_CMD="mysqldump -h ${{ inputs.src_host }} -u ${{ inputs.src_user }} -p'${SRC_PASS}' --single-transaction --quick --routines --triggers --events --set-gtid-purged=OFF --databases ${{ github.event.inputs.database_name }} 2>/dev/null | mysql -h ${{ inputs.tgt_host }} -u ${{ inputs.tgt_user }} -p'${TGT_PASS}' 2>/dev/null && echo 'Replication completed successfully' || echo 'Replication failed'"
        
        # Send replication command to EC2 via SSM
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.SSM_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --comment "RDS Database Replication" \
          --parameters "commands=[\"$REPLICATION_CMD\"]" \
          --timeout-seconds 3600 \
          --query "Command.CommandId" \
          --output text)
        
        echo "SSM Command ID: $COMMAND_ID"
        echo "‚è≥ Replication in progress... This may take several minutes depending on database size."
        
        # Wait for command to complete (with longer timeout for large databases)
        aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --timeout 3600 || true
        
        # Get command status and output
        STATUS=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "Status" \
          --output text)
        
        OUTPUT=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardOutputContent" \
          --output text)
        
        ERROR_OUTPUT=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardErrorContent" \
          --output text)
        
        echo "Command Status: $STATUS"
        echo "Output: $OUTPUT"
        
        if [ ! -z "$ERROR_OUTPUT" ]; then
          echo "Errors: $ERROR_OUTPUT"
        fi
        
        # Check if replication was successful
        if [ "$STATUS" = "Success" ] && echo "$OUTPUT" | grep -q "Replication completed successfully"; then
          echo "‚úÖ Replication completed successfully!"
        else
          echo "‚ùå Replication failed"
          exit 1
        fi
        
    - name: Verify Replication via SSM
      env:
        SRC_PASS: ${{ inputs.src_pass }}
        TGT_PASS: ${{ inputs.tgt_pass }}
      run: |
        echo "üîç Verifying replication..."
        
        # Get source table count
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.SSM_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --comment "Get source table count" \
          --parameters "commands=[\"mysql -h ${{ inputs.src_host }} -u ${{ inputs.src_user }} -p'${SRC_PASS}' -N -e \\\"SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA='${{ github.event.inputs.database_name }}'\\\" 2>/dev/null\"]" \
          --query "Command.CommandId" \
          --output text)
        
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ secrets.SSM_INSTANCE_ID }} --timeout 30 || true
        
        SRC_TABLES=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardOutputContent" \
          --output text | tr -d '\n')
        
        # Get target table count
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids ${{ secrets.SSM_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --comment "Get target table count" \
          --parameters "commands=[\"mysql -h ${{ inputs.tgt_host }} -u ${{ inputs.tgt_user }} -p'${TGT_PASS}' -N -e \\\"SELECT COUNT(*) FROM information_schema.TABLES WHERE TABLE_SCHEMA='${{ github.event.inputs.database_name }}'\\\" 2>/dev/null\"]" \
          --query "Command.CommandId" \
          --output text)
        
        aws ssm wait command-executed --command-id $COMMAND_ID --instance-id ${{ secrets.SSM_INSTANCE_ID }} --timeout 30 || true
        
        TGT_TABLES=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.SSM_INSTANCE_ID }} \
          --query "StandardOutputContent" \
          --output text | tr -d '\n')
        
        echo "Source tables: $SRC_TABLES"
        echo "Target tables: $TGT_TABLES"
        
        if [ "$SRC_TABLES" = "$TGT_TABLES" ] && [ ! -z "$SRC_TABLES" ]; then
          echo "‚úÖ Verification passed - Table counts match!"
        else
          echo "‚ö†Ô∏è  Warning: Table count mismatch or verification failed"
          exit 1
        fi
